---
title: State Management
description: Managing data flow properly using Provider.
---

import { Steps } from '@astrojs/starlight/components';

# State Management

While `setState` is great for local widget state (like a checkbox toggle), you need a robust solution for **App State** (User profile, Shopping Cart, Authentication status).

## The Requirement

We need to access data from anywhere in the app and rebuild UI when that data changes. We recommend **Provider** for beginners as it's standard, widely used, and maintained by Google.

## Implementing Provider

<Steps>

1.  **Add Dependency**:
    ```yaml
    dependencies:
      provider: ^6.1.1
    ```

2.  **Create a Model (ChangeNotifier)**:
    This class holds your data and notifies listeners when it changes.

    ```dart
    import 'package:flutter/material.dart';

    class CounterModel extends ChangeNotifier {
      int _count = 0;
      int get count => _count;

      void increment() {
        _count++;
        notifyListeners(); // This triggers the UI rebuild
      }
    }
    ```

3.  **Provide the Model**:
    Wrap your app (or the part that needs access) with `ChangeNotifierProvider`.

    ```dart
    void main() {
      runApp(
        ChangeNotifierProvider(
          create: (context) => CounterModel(),
          child: const MyApp(),
        ),
      );
    }
    ```

4.  **Consume the Data**:
    Use `Consumer` or `Provider.of` to access the data.

    ```dart
    // In your widget build method
    Consumer<CounterModel>(
      builder: (context, counter, child) {
        return Text('Count: ${counter.count}');
      },
    );
    ```

    Or for methods (like button clicks), access it without listening:
    ```dart
    FloatingActionButton(
      onPressed: () {
        // listen: false is important here!
        Provider.of<CounterModel>(context, listen: false).increment();
      },
      child: Icon(Icons.add),
    )
    ```

</Steps>

## Other Popular Solutions

-   **Riverpod**: The "V2" of Provider. Compile-time safe, no context dependency. Highly recommended for production.
-   **Bloc**: Business Logic Component. Rigid structure, great for large teams and complex logic.
-   **GetX**: All-in-one (State, Nav, DI). easy to start but can lead to bad habits.
